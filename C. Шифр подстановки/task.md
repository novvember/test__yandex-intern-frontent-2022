## C. Шифр подстановки

Современные методы шифрования надёжно защищают наши коммуникации даже в условиях, когда взломщик может делать миллионы попыток дешифровки в секунду. В докомпьютерную же эпоху шифрование и расшифровка сообщений была кропотливым ручным трудом даже для того, у кого был ключ к шифру. Но и сами шифры были проще.

Одним из простейших методов шифрования является шифр подстановки, когда один или несколько исходных символов заменяются на один или несколько других.

Реализуй функцию decode, удовлетворяющую следующим условиям:

- Специальных преобразовний регистра делать не нужно, заглавные и строчные буквы - это разные буквы:  
  `decode('Aa', [{ from: 'a', to: 'b' }]) === 'Ab'`

- Части исходного сообщения, не требующие замены, остаются, как есть:  
  `decode('ab', [{ from: 'a', to: 'b' }]) === 'bb'`

- Уже заменённые символы нельзя заменять повторно.:  
  `decode('ab', [{ from: 'a', to: 'ba' }, { from: 'b', to: 'r' }]) === 'bar'`

- Зашифрованное сообщение расшифровывается слева направо. Замена, встретившаяся в слове раньше, имеет приоритет.:  
  `decode('ab', [{ from: 'b', to: 'bar' }, { from: 'ab', to: 'foo' }]) === 'foo'`

- При совпадении позиции нескольких замен в слове та замена, о которой договорились позже, имеет приоритет.:  
  `decode('ab', [{ from: 'a', to: 'bar' }, { from: 'ab', to: 'foo' }]) === 'foo'`

## Примечания

Не забудь проверить граничные случаи – пустой массив замен и замену на пустую строку.

Код решения должен экспортировать функцию decode с правильной сигнатурой через module.exports. Шаблон для удобства:

```
/**
 *
 * @typedef Replace
 *
 * @property {string} from
 * @property {string} to
 */

/**
 *
 * @param {string} message
 * @param {Replace[]} replaces
 * @returns {string}
 */

function decode(message, replaces) {
 // Ваш код
}

module.exports = { decode };
```
